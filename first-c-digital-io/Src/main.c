/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {

	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;

	/*
	@ enable the clocks for peripherals (GPIOA, C and E)
	LDR R0, =RCC  @ load the address of the RCC address boundary (for enabling the IO clock)
	LDR R1, [R0, #AHBENR]  @ load the current value of the peripheral clock registers
	ORR R1, 1 << GPIOA_ENABLE | 1 << GPIOC_ENABLE | 1 << GPIOE_ENABLE  @ 21st bit is enable GPIOE clock, 17 is GPIOA clock
	STR R1, [R0, #AHBENR]  @ store the modified register back to the submodule
	BX LR @ return from function call
	*/
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {

	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
	*led_output_registers = 0x5555;

	/*
	LDR R0, =GPIOE 	@ load the address of the GPIOE register into R0
	LDR R1, =0x5555 @ load the binary value of 01 (OUTPUT) for each port in the upper two bytes
					@ as 0x5555 = 01010101 01010101
	STRH R1, [R0, #MODER + 2]   @ store the new register values in the top half word representing
								@ the MODER settings for pe8-15
	BX LR @ return from function call
	*/
}


int main(void)
{
	enable_clocks();
	initialise_board();


	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	*led_register = 0b10101010;

    /* Loop forever */
	for(;;) {

		*led_register ^= 0xff;
		/*
		LDR R0, =GPIOE  @ load the address of the GPIOE register into R0
		STRB R4, [R0, #ODR + 1]   @ store this to the second byte of the ODR (bits 8-15)
		EOR R4, #0xFF	@ toggle all of the bits in the byte (1->0 0->1)
		*/

		while ((GPIOA->IDR & 0x01) == 0) {};
		/* Look at the digital I/O (separate file!)
		loop_until_pressed:
			LDR R0, =GPIOA
			LDR R1, [R0, IDR]
			TST R1, 0x01 @ PA0 is bit 0, so test for equal to this
			BEQ loop_until_pressed @ loop while TST returns 0
		*/

		while ((GPIOA->IDR & 0x01) != 0) {};
		/*
		loop_until_not_pressed:
			LDR R0, =GPIOA
			LDR R1, [R0, IDR]
			TST R1, 0x01 @ PA0 is bit 0, so test for equal to this
			BNE loop_until_pressed @ loop while TST returns 0
		*/
	}
}
