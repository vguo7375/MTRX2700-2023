/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "serial.h"
#include "movement.h"


#include "stm32f303xc.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void finished_transmission(uint32_t bytes_sent) {
	// This function will be called after a transmission is complete

	volatile uint32_t test = 0;
	// make a very simple delay
	for (volatile uint32_t i = 0; i < 0x8ffff; i++) {
		// waste time !
	}
}


void ShapeDemo();
const int NUMBER_OF_SHAPES = 16;


int main(void)
{
	uint8_t *string_to_send = "This is a string !\r\n";

	void (*completion_function)(uint32_t) = &finished_transmission;

	SerialInitialise(BAUD_115200, &USART1_PORT, completion_function);

	ShapeDemo();

	/* Loop forever */
	for(;;) {
		SerialOutputString(string_to_send, &USART1_PORT);
	}
}


void ShapeDemo(void) {

	struct shape shape_1 = generate_shape(SHAPE_SPHERE, 5, 5);
	struct shape shape_2;
	struct shape *shape_3;

	struct shape shape_array[16];

	uint8_t string_buffer[64];

	shape_string(&shape_1, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	shape_string(&shape_2, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	shape_3 = (struct shape*)malloc(sizeof(struct shape));
	shape_string(shape_3, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	*shape_3 = generate_shape(SHAPE_CONE, 6,3);
	shape_string(shape_3, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);


	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		if (initialise_shape(&shape_array[counter], counter % 3, 3, 4)) {
			shape_string(&shape_array[counter], &string_buffer[0]);
			SerialOutputString(&string_buffer[0], &USART1_PORT);
		} else {
			shape_string(&shape_array[counter], &string_buffer[0]);
			SerialOutputString(&string_buffer[0], &USART1_PORT);
		}
	}

	// slide the shapes
	sprintf(&string_buffer[0], "sliding the shapes by 1.5 units\r\n");
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		slide_shape(&shape_array[counter], 1.5);
		shape_string(&shape_array[counter], &string_buffer[0]);
		SerialOutputString(&string_buffer[0], &USART1_PORT);
	}

	// roll the shapes
	sprintf(&string_buffer[0], "rolling the shapes by 2.5 units\n");
	SerialOutputString(&string_buffer[0], &USART1_PORT);
	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		roll_shape(&shape_array[counter], 2.5);
		shape_string(&shape_array[counter], &string_buffer[0]);
		SerialOutputString(&string_buffer[0], &USART1_PORT);
	}

}

