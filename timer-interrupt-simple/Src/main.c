/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {

	// enable the clocks for peripherals (GPIOA, C and E)
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;

	// store a 1 in bit for the TIM2 enable flag
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {
	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
	*led_output_registers = 0x5555;
}


int main(void)
{
	// Disable the interrupts while messing around with the settings
	//  otherwise can lead to strange behaviour
	__disable_irq();

	// enable the devices
	enable_clocks();
	initialise_board();

	// setup the LEDs
	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	*led_register = 0b00000001;

	// enable the timer 2 through the RCC registers
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	// set the prescaler so that 1 count is 1 microsecond
	//  8MHz = 0.000000125, 1 microsecond is 0.000001,
	//	prescaler 0.000001/0.000000125 = 8
	TIM2->PSC = 8;  // 1 microsecond / count
	TIM2->ARR = 1000000; // 1 second before reset

	// make the timer2 trigger an interrupt when there is an overflow
	TIM2->DIER |= TIM_DIER_UIE;

	// make the timer2 trigger an interrupt when there is
	//  a successful output compare (on channel 1)
	TIM2->DIER |= TIM_DIER_CC1IE;

	// finally, enable the timer2
	TIM2->CR1 |= TIM_CR1_CEN;

	// Tell the NVIC module that timer2 interrupts should be handled
	NVIC_EnableIRQ(TIM2_IRQn);

	// Enable the output Capture/Compare for channel 1
	TIM2->CCER |= TIM_CCER_CC1E;
	TIM2->CCR1 = 100000; // 50% duty cycle (500000/1000000)

	// Re-enable all interrupts (now that we are finished)
	__enable_irq();

    /* Loop forever */
	for(;;);
}


void TIM2_IRQHandler(void)
{
	//branch based on the flag
	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	// the status register tells us why the interrupt was called
	// UIF is from an overflow type event
	if ((TIM2->SR & TIM_SR_UIF) != 0){
		// set the LED state to be a specific value
		*led_register = 0xf0;
		TIM2->SR &= ~TIM_SR_UIF;
	}

	// CC1IF is from a successful output compare
	if ((TIM2->SR & TIM_SR_CC1IF) != 0){
		// set the LED state to be a specific value
		*led_register = 0x0f;
		TIM2->SR &= ~TIM_SR_CC1IF;
	}
}
